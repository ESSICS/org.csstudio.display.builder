<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
  <title>Display Builder</title>
  <link rel="stylesheet" href="PLUGINS_ROOT/PRODUCT_PLUGIN/book.css" type="text/css"></link>
  <style>
	  table {
		  border: 1px solid black;
	  }
	  th {
		  padding: 6px;
		  text-align: center;
		  border-bottom: 1px solid #777;
	  }
	  td {
		  padding: 6px;
		  text-align: left;
		  border-bottom: 1px solid #ddd;
	  }
  </style>
</head>
<body>

<!-- Aiming for one long file to allow printing of the complete 'manual'.

     Exception: javadoc API
  -->

<h1>Display Builder</h1>

<h2>Table of Contents</h2>

<!-- Topics are duplicated in toc.xml -->

<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#get_started">Getting Started</a></li>
<li><a href="#editor">Display Editor</a></li>
<li><a href="#conversion">BOY <i>*.opi</i> File Conversion</a></li>
<li><a href="#runtime">Display Builder Runtime, Display Runtime Perspective</a></li>
<li><a href="#widgets">Widgets</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#widgets_detail">Widget Details</a></li>
<li><a href="#rules">Rules</a></li>
<li><a href="#scripts">Scripts</a></li>
</ol>

<!-- ====================================================== -->
<h1><a name="overview">Overview</a></h1>
<!-- ====================================================== -->

<p>The Display Builder is a panel editor and runtime for control system displays.
</p>


<h1><a name="get_started">Getting Started</a></h1>

<h2>Display Builder Examples</h2>

<p>The Display Builder example files demonstrate many of its widgets and features.
</p>

<center>
	<img src="images/GettingStarted_samples1.png" alt="CS-Studio > Utilities > Install Samples" width="400" style="vertical-align:top;padding-right:16px"/>
	<img src="images/GettingStarted_samples2.png" alt="X/Y Plot Widget example" width="400" style="vertical-align:top"/>
</center>

<p>Open the menu <b>CS-Studio</b> > <b>Utilities</b> > <b>Install Samples</b>.
Select <i>Display Builder</i> and click OK.
The examples will be in a project folder named "Display Builder".
</p>

<p>Start the first example display, <b>01_main.bob</b>, by right-clicking on the file in the Navigator and selecting 
<b>Open With...</b> > <b>Display Runtime</b>.
</p>


<!-- ====================================================== -->
<h1><a name="editor">Display Editor</a></h1>
<!-- ====================================================== -->

<p>You use the Display Editor to create new display files or to modify existing display files.
</p>

<h2>Display Editor Perspective</h2>

<p>The Display Editor perspective offers the tools and settings needed to edit
Display Builder (*.bob) files.
From CS-Studio, the Display Editor perspective
can be opened from the menu bar: <b>Window</b> > <b>Open Perspective</b> > <b>Other...</b>,
then select <b>Display Editor</b>.
</p>

<p>Alternatively, if you are already inside the display editor, 
right-click in the central Editor part and select <b>Open Editor Perspective</b>.
This will open the Display Editor perspective,
or - in case are already in that perspective -
a dialog will ask if you want to reset the perspective to its default layout.
</p>


<h2>Creating a New Display</h2>

<p>From within the Display Editor perspective, right-click on a project in the Navigator and select
<b>New</b> > <b>New Display</b>.
This will open the New Display wizard where you enter the name of your new display file.
</p>

<p>Alternatively, you can use the menu
<b>File</b> > <b>New...</b>, and under <i>Display Editor</i>, select <b>New Display</b>.
Then choose a container and name for the new display file in the New Display wizard.
</p>

<h2>Editing an Existing Display</h2>

<p>Right-click on a <i>*.bob</i> or <i>*.opi</i> file in the Navigator and select
<b>Open With...</b> > <b>Display Editor</b> (or <b>Other</b> > <b>Display Editor</b>). 
</p>

<p>If you are already executing a display, you can open that display file in the editor
by right-clicking anywhere in the display runtime and selecting <b>Open in Editor</b>.
</p>

<h2>Executing a display from the Editor</h2>

<p>Right-click anywhere in the editor pane and select <b>Execute Display</b>
to start a Display Runtime for the file.
This will automatically save the file, so any pending changes
will be written to the *.bob file.
</p>


<h2><a name="drag_and_drop">Drag &amp; Drop</a></h2>

<p>Most of the editing is performed dragging things around:</p>
<ul>
	<li>adding widgets dragging them from the <em>Widget Palette</em> into the editor,</li>
	<li>selecting multiple widgets "rubber banding" around them,</li>
	<li>moving existing widgets,</li>
	<li>resizing existing widgets,</li>
	<li>adding text, images or files from outside into the editor.</li>
</ul>

<h3>Adding Widgets</h3>

<img src="images/DragAndDrop_adding_widget.png" alt="Adding widgets from Widget Palette." style="float:right;margin:0 0 0px 8px;"/>

<p>
	Widgets can be added dragging them from the <em>Widget Palette</em> into the editor.
	As soon as the mouse button is released the widget is added to the editor:
</p>

<ul>
	<li>at the cursor position, if the <em>Align widgets to Grid</em> button is not selected,</li>
	<li>aligned to the closest grid position, if the <em>Align widgets to Grid</em>
		button is selected.</li>
</ul>

<p>
	The added widget will be automatically selected, allowing to be quickly moved or
	resized.
</p>

<p>
	<strong>Note:</strong> The dragging outline image is not displayed on all platforms
	because of a known issue in the FXCanvas class on Java 8. It will be solved in the
	upcoming Java 9 release.
</p>

<h3 style="clear:right">Rubber Band Selection</h3>

<p>
	A single widget can be selected clicking on it. Single and multiple widgets can be selected
	also rubber banding around it, i.e. Clicking on the editor's white background and, while
	keeping the mouse button depressed, dragging unting the dashed rubber band encloses all
	the interested widgets. When the mouse button will be released, selected widgets will be
	surrounded by the selection outline.
</p>

<p>
	Once one or more widgets are selected, they can be moved and resized as a single entity,
	as explained in the following paragraphs.
</p>

<center>
	<img src="images/DragAndDrop_rubber_band_selection.png" alt="Rubber band selection." width="600"/>
</center>

<h3>Moving Widgets</h3>

<img src="images/DragAndDrop_moving.png" alt="Moving a widget." style="float:right;margin:0 0 0px 8px;"/>

<p>
	Once widgets are selected, it is possible to move them around by clicking inside the selection
	outline and dragging. The selection outline will follow the cursor movements until the
	mouse button will be released, and the widgets will be actually moved.
</p>

<p>
	If the <em>Align widgets to Grid</em> button is selected, then the selection outline
	will align to grids when moving.
</p>

<p>
	If the <em>Snap to widgets</em> button is selected, then the selection outline
	will align to existing widgets' edges when moving, displying a cyan alignment ruler.
</p>

<h3 style="clear:right">Resizing Widgets</h3>

<img src="images/DragAndDrop_resizing.png" alt="Resizing a widget." style="float:right;margin:0 0 0px 8px;"/>

<p>
	Once widgets are selected, it is possible to resize them by clicking inside one of the
	selection outline's handles and dragging. The selection outline will follow the cursor
	movements until the mouse button will be released, and the widgets will be actually resized.
</p>


<p>
	If the <em>Align widgets to Grid</em> button is selected, then the selection outline
	will align to grids when resizing.
</p>

<p>
	If the <em>Snap to widgets</em> button is selected, then the selection outline
	will align to existing widgets' edges when resizing, displying a cyan alignment ruler.
</p>

<h3 style="clear:right">D&D From Outside</h3>

<p>
	Different entities dragged from outside the editor can be dropped in. When the nature
	of these entities is compatible, the editor will accept the drag an drop operation
	creating a series of widgets.
</p>

<h4>Dropping Images</h4>

<p>
	An image (possibly dragged from a web browser) can be dropped into the editor.
	That image will be saved into a temporary location and Picture widget will be
	created pointing the the saved image file.
</p>

<p>
	<strong>Note:</strong> The created Picture widget will have its top-left
	corner at the location (possibly snapped to grid) wher the cursor was when
	the image was dropped.
</p>

<p>
	The created widget will be automatically sized the to dropped image size.
</p>

<center>
	<img src="images/DragAndDrop_image_drag.png" alt="Image drag." width="400" style="vertical-align:middle;padding-right:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_image_drop.png" alt="Image drop." width="400" style="vertical-align:middle;padding-left:8px"/>
</center>

<h4>Dropping Files</h4>

<p>
	Image files (with extension <code>.bmp</code>, <code>.gif</code>, <code>.jpeg</code>,
	<code>.jpg</code>, and <code>.png</code>) and OPI files (with extension
	<code>.bob</code>, and <code>.opi</code>) can be dropped into the editor.
	Image files will create Picture widgets, while OPI files will create
	Embedded Display ones. The created widget will reference the dropped file,
	using (if possible) a relative path location.
</p>

<p>
	Multiple files can be dropped at once. Each one will create its own corresponding
	widget (Picture or Embedded Display), that will be offset by a grid step in
	both coordinates from the preceeding one.
</p>

<h4 style="clear:right">Dropping URLs</h4>

<p>
	When dropping a URL into the editor, one of the following situations occurs:
</p>

<ul>
	<li>
		The URL string ends with one of the supported image extensions (<code>.bmp</code>,
		<code>.gif</code>, <code>.jpeg</code>, <code>.jpg</code>, and <code>.png</code>),
		then a Picture widget will be created and positioned under the (possibly aligned
		to grid) cursor position;
	</li>
	<li>
		The URL string ends with one of the supported OPI extensions (<code>.bob</code>,
		and <code>.opi</code>), then an Embedded Display widget will be created and
		positioned under the (possibly aligned to grid) cursor position;
	</li>
	<li>
		Otherwise a dialog will open allowing the user to chose the widget to be
		created.
	</li>
</ul>

<center>
	<img src="images/DragAndDrop_url.png" alt="Dropping an URL."/>
</center>

<h4>Dropping Text</h4>

<p>
	A text can be composeb by a single or multiple lines, an each line can be
	interpreted as a PV name. For this reason a dialog will open allowing to select
	a single Label widget (displaying the whole text), multiple Label Widgets
	(displaying a line each), or multiple widgets (of the same type) using each
	line as a PV name.
</p>

<p>
	Multiple widgets will be offset by a grid step in booth coordinates from the
	preceeding one.
</p>

<center>
	<img src="images/DragAndDrop_text1.png" alt="Text drag." width="200" style="vertical-align:middle;padding-right:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_text2.png" alt="Text drop." width="300" style="vertical-align:middle;padding-left:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_text3.png" alt="Widgets created." width="300" style="vertical-align:middle;padding-left:8px"/>
</center>





<!-- ====================================================== -->
<h1 style="clear:right"><a name="conversion">BOY <i>*.opi</i> File Conversion</a></h1>
<!-- ====================================================== -->

<p>The Display builder automatically convert BOY <i>*.opi</i> files.
Whenever you open a <i>*.opi</i> file, the Display Builder maps all legacy widgets
to the new widgets and their corresponding properties.
</p>

<p>In many cases, existing <i>*.opi</i> require no changes at all to execute properly
in the Display Builder runtime.
This means you can simply select an existing <i>*.opi</i> file
in the Navigator and use the <b>Open With...</b> > <b>Display Runtime</b> context menu
to execute the display.
Likewise, actions that open related displays in legacy <i>*.opi</i> file format
will automatically load, convert and execute those.
</p>

<p>Sometimes, you may want to slightly rearrange widgets to look better
in the Display Runtime.
In rare cases, you will have to edit the file because widget behavior has changed.
Also beware that most <a href="#scripts">scripts</a> associated with the display need to be updated.
Scripts are the most likely cause of failures in converted files.
Finally, you might simply want to change the display to get new behavior.
</p>

<p>To edit, simply right-click on any <i>*.opi</i> file in the Navigator and use
<b>Open With...</b> > <b>Display Editor</b> to load the legacy file into the Display Builder editor.
If you are already executing the file in the Display Builder runtime,
use the context menu to <b>Open in Editor</b>.
You can now edit the file.
When saving the file, the file name is changed to <i>*.bob</i>.
</p>

<h2>Transition Hints</h2>

<p>Whenever the Display Builder is asked to open a <i>*.opi</i> file,
it will check for an alternate <i>*.bob</i> file.
</p>

<p>To transition from BOY to the Display Builder, it is thus best
to start with the existing <i>*.opi</i> files.
For those files that need to be adjusted,
edit the <i>*.opi</i> file and save it as a new <i>*.bob</i> file,
but keep the previous <i>*.opi</i> file.
This way, BOY can still be used with the existing files,
while the Display Builder will select the converted files,
and both tools can thus be used in parallel until all
files that need adjustments have been updated.
</p>

<p>If the only change required in a <i>*.opi</i> file
relates to a script, that script can be made bilingual
by following the Display Builder <a href="#get_started">example</a>
from <i>Display Builder/script_util/porting.opi</i> and
<i>Display Builder/script_util/portable.py</i>.
</p>


<!-- ====================================================== -->
<h1><a name="runtime">Display Builder Runtime, Display Runtime Perspective</a></h1>
<!-- ====================================================== -->

<h2>Display Builder Runtime</h2>

<p>When you execute a display, the Display Builder runtime
opens the <i>*.bob</i> (or legacy <i>*.opi</i>) file,
connects to process variables, displays their value in Text Update widgets etc.
</p>

<p>When you right-click on a widget,
the first entry in the context menu which shows the name of the widget
opens an information panel for the widget.
Additional entries allow saving a snapshot of the display,
or to re-load the display.
</p>


<h2>Display Runtime Perspective</h2>

<p>For a production setup,
use the Display Builder "Top Displays" preference to configure a list of top level displays,
i.e. starting points for your users.
</p>

<p>Then open the Display Runtime Perspective, and use either the menu
<b>File</b> > <b>Top Displays</b>
or the Top Displays drop-down button in the tool bar to open these
from within the Display Runtime Perspective.
</p>

<p>Typically, at least one such Display Runtime Perspective with a pre-arranged
displays layout is then saved as a named Perspective
and used as a default layout.
</p>



<!-- ====================================================== -->
<h1><a name="widgets">Widgets</a></h1>
<!-- ====================================================== -->

<p>Widgets are the components of Display Builder displays.
In the editor, you add Widgets to the display by dragging them
from the Widget Palette into the editor.
Then you typically adjust the location and size,
and enter a text or PV name by configuring the corresponding property.
</p>

<!-- ====================================================== -->
<h1><a name="properties">Properties</a></h1>
<!-- ====================================================== -->

<img src="images/tracker.png" alt="Tracker" style="float:right;margin:0 0 0px 8px;"/>

<p>Every widget has properties <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b>
that define its position and size within the display.
While these properties can be entered in the Properties View,
a widget can also be moved interactively by moving the selected widget
in the editor with the mouse,
and the size can be changed by moving the square handles in the corner of the selected widget with the mouse.
</p>

<p><b>Label</b> widgets have a <b>text</b> property for configuring the text
shown in the label.
Many widgets have a <b>pv_name</b> property for configuring the name of the
PV that the widget will display or control at runtime.
These key properties can be edited by double-clicking the selected widget
and then entering the text or pv_name.
</p>

<h2 style="clear:right">Properties View</h2>

<img src="images/properties_palette.png" alt="Properties View" style="float:right;margin:0 0 0px 8px;"/>

<p>In general, properties are edited in the <b>Properties View</b>.
It lists every property of a widget with its current value,
and except for very few static properties it allows entering or selecting different values.
</p>

<h2>Property Names</h2>

<p>The "Properties" panel will show each property with a description like "X Position", "Text" or "PV Name".
This is the localized description of each property which might be different in for example a German version of the Display Builder.
Each property also has a unique name that is used in the <i>*.bob</i> file
or when accessing a property from a <a href="#rules">rule</a> or <a href="#scripts">script</a>.
The name of a property is typically based on the simplified English description, all lower case:
<b>x</b>, <b>text</b>, <b>pv_name</b>.
</p>

<p>The Property View shows the underlying name of each property in a tool tip
that appears when you hover the mouse over the property description.
In the following description of properties, we always use the property name.
</p>


<h2>Common Properties</h2>

<p>Key properties common to most widgets include:</p>
<ul>
  <li><b>type</b>: Type of widget (e.g. label, text_update). Each widget has both a localizable (translatable)
                   type name and an internal type name used to identify the widget type in display files.
  </li>
  <li><b>name</b>: Used to identify the widget. Is best made unique within the display.</li>
  <li><b>x</b>, <b>y</b>, <b>width</b> and <b>height</b>: Location and size of the widget.
                   Can be configured in the Property view, but are typically adjusted using the
                   mouse on the selected widget.
  </li>
  <li><b>text</b>: Text that a Label widget displays. Can also be configured via double-click on the widget.</li>
  <li><b>pv_name</b>: The PV that the widget uses to read or write values. Can also be configured via double-click on the widget.</li>
  <li><b>actions</b>: Attach Actions that do things like open displays or run scripts.
                      Primarily used with the <b>Action Button</b> widget.
  </li>
</ul>
  
<p>Each widget has several additional properties that for example allow the configuration
of colors, the formatting of texts etc.
Ideally, you can create a functional control system display by configuring the basic
properties of a widget, relying on the default behavior of a widget.
For special cases, widgets also support the following properties:
</p>
  
<ul>
  <li><b>rules</b>: Attach <a href="#rules">Rules</a> that dynamically assign widget property values based on conditional expressions.
  </li>
  <li><b>scripts</b>: Attach <a href="#scripts">Scripts</a> that dynamically control widget appearance and behavior.
  </li>
</ul>

<h2>Array and Structure Properties</h2>

<p>Some widgets contain properties that are arrays and/or structures.
For example, the <b>Multi-State LED</b> has a <b>states</b> property that is an array.
The elements of the array are in turn structures with a <b>value</b> and a <b>color</b>.
For access from Rules or Scripts these properties can be accessed via names (for structured
properties) and indices (for array properties).
Example:
</p>
<pre>states[0].value</pre>
<pre>states[1].color</pre>


<!-- ====================================================== -->
<h1 style="clear:left"><a name="widgets_detail">Widget Details</a></h1>
<!-- ====================================================== -->

<p>For details on each widget refer to the 
<a href="#get_started">example displays.</a>
They showcase each widget, explain their key properties,
and in some cases (polygon, polyline) also provide
hints for editing them.
</p>

<!-- ====================================================== -->
<h1><a name="rules">Rules</a></h1>
<!-- ====================================================== -->

<p>Rules are the suggested way to obtain customized, dynamic behaviors beyond the capability of
<a href="#properties">widget properties</a> alone. (The other is <a href="#scripts">scripts</a>.
Rules are recommended over scripts because, while rules are more limited than scripts, the API is stable,
and it should remain available and virtually unchanged as Display Builder evolves.)
</p>

<p>Unlike scripts, rules require no code aside from simple expressions. Rules set widget property
values according to boolean expressions using their input PVs. Since the execution of a rule is
triggered by its trigger PVs, at least one input PV is needed for a rule.
</p>

<h2>Attaching a Rule to a Widget</h2>
<p>In order to edit the Rules for a widget, first select it, then click on the button
for its Rules property in the Properties palette. This will open the Rules dialog.
</p>

<center>
	<img src="images/Rules.png" alt="Rules Dialog" style="height:456px;"/>
</center>

<p>Key features include:</p>
<ul>
  <li>Rule Name: Add and remove rules here. Select a rule to edit its properties.</li>
  <li>PVName: Add and remove input PVs for the rule. If "Trigger" is checked (true),
	  then the rule will execute whenever the PV's value changes.</li>
  <li>Property ID: The property which is affected by the rule.</li>
  <li>Boolean expression: The expression which is evaluated when the rule executes. If it is
	  true, the property's value will be set to the expression's "Value" field. The expression may simply be
	  "true" or "True", in which case the value is always used (this is most useful when "Value as Expression"
	  is checked).
  </li>
  <li>Value as Expression: If true, all values for the rule are given as expressions.</li>
</ul>

<h2>Expressions</h2>
<p>The standard comparison operators (&lt;, &gt;, ==, &lt;=, &gt;=, and !=) may be used. Logical
operators may also be used. All input PVs of the rule are accessible as follows:
</p>
<center>
	<table>
		<tr>
			<th>Value Type</th>
			<th>Syntax</th>
			<th>Example</th>
		</tr>
		<tr>
			<td>double value</td>
			<td><code>pv{index}</code></td>
			<td><code>pv0 > pv1</code></td>
		</tr>
		<tr>
			<td>long int. value</td>
			<td><code>pvInt{index}</code></td>
			<td><code>pvInt0 == 5</code></td>
		</tr>
		<tr>
			<td style="border-bottom: 0px">string value</td>
			<td style="border-bottom: 0px"><code>pvStr{index}</code></td>
			<td style="border-bottom: 0px"><code>pvStr0 == "happy"</code></td>
		</tr>
	</table>
</center>


<!-- ====================================================== -->
<h1><a name="scripts">Scripts</a></h1>
<!-- ====================================================== -->

<h2>Purpose</h2>

<p>Ideally, a control system display can be created by
simply adding several widgets and configuring their
properties. In many cases, only the location, size
and PV name of a widget needs to be configured.
</p>

<p>There are cases, however, where the built-in
widget functionality is not sufficient.
Traditionally, this would be handled by developing a custom,
site-specific user interface tool.
The display builder script support often allows you
to avoid the creation of such a custom tool.
</p>


<h2>Basic Functionality</h2>

<p>Scripts are invoked from
</p>

<ul>
<li>PV changes</li>
<li>Actions</li>
</ul>

<p>The script always receives the <code>widget</code> which invoked it.
A script associated with PVs also receives the <code>pvs</code>
which might have triggered its invocation.
</p>


<h2>PV Scripts</h2>

<p>Example of invoking a script from PV changes:
</p>

<ol>
<li>Create a Label widget</li>
<li>On its Scripts property, add a script by either specifying the path to the script,
    typically in a form relative to the location of the *.bob file,
    or enter the "embedded" script text.
</li>
<li>Add at least one PV. Enter its name, note that "Trigger" is by default selected.</li>
<li>You may add more PVs. Assert that at least one has the "Trigger" selected.</li>
</ol>

<p>At runtime, a connection is established to all PVs.
Whenever PVs marked as a "Trigger" change their value,
the script is invoked.
The script will receive a <code>widget</code> parameter
that holds the Label, and a <code>pvs</code> parameter
that holds a list of all PVs assigned to the script.
</p>

<p>A typical example is a script that reads the values of its PVs,
computes something, and uses the result to update one or more properties of the
widget:
</p>

<pre>
value = PVUtil.getDouble(pvs[0]);
if value >= 0:
    result = "Positive"
else:
    result = "Negative"
widget.setPropertyValue("text", result)
</pre>


<h2>Action Scripts</h2>

<p>Example of invoking a script from an Action:
</p>

<ol>
<li>Create an Action Button widget</li>
<li>On its Actions property, add an "Execute Script" action</li>
<li>Enter the path to the script, typically in a form relative to the location of the *.bob file,
    or enter the "embedded" script text.
</li>
</ol>

<p>At runtime, pushing the button will invoke the script.
The script receives a <code>widget</code> parameter
that holds the Action Button.
</p>

<p>A typical example is a script that performs some
action outside of the display tool,
then maybe displays the result in other widgets
which it locates based on their name:
</p>

<pre>
result = InvokeSomeCodeThatDoesSomething()

children = widget.getDisplayModel().runtimeChildren()
other = children.getChildByName("name_of_other_widget")

other.setPropertyValue("text", result)
</pre>


<h2>Jython Script</h2>

<p>Jython scripts are written in Python syntax, i.e. a very well designed, robust language.
They execute within the same Java instance that also executes the display builder
and have access to the complete API, including undocumented code.
</p>

<p>Any script file with a name that ends in ".py" which does not contain the word "python"
in its first line is executed as a Jython script.
In addition, the code of Jython scripts can be embedded in the *.bob file.
</p>

<p>As a downside, Jython scripts do not have access to the complete set of
native Python libraries, for example numpy.
</p>


<h2>Python Scripts</h2>

<p>Python scripts are executed by a native Python interpreter outside of the display builder.
They access key Display Builder API via networked proxies using Py4J.
Python scripts have access to all native Python libraries, for example numpy.
</p>

<p>Any script file with a name that ends in ".py" which contains the word "python"
in its first line is executed as a Python script.
This is typically accomplished via the usual Python shebang
</p>

<pre>
#!/usr/bin/env python 
</pre>

<p>Python scripts must be in *.py files, they cannot be embedded in the *.bob file.
</p>

<p>As a downside, Python scripts incur some overhead at startup and whenever they
access the Display Builder API, because this is done via networked proxies.
They also depend on python being installed on the computer.
</p>

<p>To use native python scripts, python must be installed on the computer.
In addition, Py4J needs to be added if the invoked python code should
interact with the display. This is typically done via
</p>

<pre>
# For python 2.x
easy_install py4j
</pre>

<p>or</p>

<pre>
# For python 3.x
pip install py4j
</pre>


<p>For convenience, a Python module, <code>connect2j</code>, is provided with Display Builder; it implements a context
manager to manage the network connections and ensure that resources are properly released.
</p>

<p>To install <code>connect2j</code>, do the following:</p>
<ol>
<li>Under the CS-Studio installation directory, in "plugins/", locate the *.jar
    file beginning with "org.csstudio.display.builder.runtime"; that is, something
    like: <pre>org.csstudio.display.builder.runtime_1.0.0.201605162005.jar.</pre>
</li>

<li>Extract the "scripts" directory from the jar.
    <ul>
    <li>On a Unix system, you can use:
    <pre>unzip org.csstudio.display.builder.runtime_1.0.0.201605162005.jar scripts/*</pre>
    </li>
    <li>On any system with Java installed, you can use:
    <pre>jar xf org.csstudio.display.builder.runtime_1.0.0.201605162005.jar scripts/connect2j.py scripts/setup.py</pre>
    </li>
    </ul>
</li>

<li>Next, install the module:
    <pre>
cd scripts
python setup.py install
    </pre>
</li>

<li>The scripts directory which was created may now be deleted.</li>
</ol>

<p>The main API of <code>connect2j</code> is the scriptContext context manager. Simply place code which accesses
Display Builder API inside a "with" statement using scriptContext, like so:
</p>
<pre>#!/usr/bin/env python 
from connect2j import scriptContext

# Code that does not interact with Display Builder

with scriptContext('widget', 'pvs', 'ScriptUtil', 'PVUtil', dict=globals()):
    # Code that uses DisplayBuilder APIs; for example:
    value = PVUtil.getDouble(pvs[0])

# Code that does not interact with Display Builder
</pre>

<p>Above, the argument "dict=globals()" tells scriptContext to enter the previous
arguments in the calling module's global dict, where they may be accessed as global
variables and used as typical Display Builder API. Without a dict argument supplied,
the appropriate entries are made in the <code>connect2j</code> module's global dict and must be
imported from <code>connect2j</code> <em>after the script context is created</em>. Any or all of
the string arguments may be omitted, and no variables or proxies will be created for the omitted arguments.
</p>

<p>As an additional convenience, <code>connect2j.scriptContext</code> may also be used in Jython code, which will
then be identical (except for the first line) to its corresponding Python code. Automatically, scriptContext
identifies the platform on which it is being run and chooses to either use Py4J to create proxies for its
arguments, or import the given utility classes and use the 'pvs' and 'widgets' which are already accessible from Jython.
</p>

<h2>Comparison: Python and Jython</h2>
<center>
	<table>
		<tr>
			<th></th>
			<th>Native Python</th>
			<th>Jython</th>
		</tr>
		<tr>
			<td><b>requirements</b></td>
			<td>*.py file, "python" first line (i.e. shebang)</td>
			<td>*.py (file or url) or embedded script</td>
		</tr>
		<tr>
			<td><b>API</b></td>
			<td>scriptContext (must be installed)
				<ul>
					<li>widget, pvs</li>
					<li>PVUtil</li>
					<li>ScriptUtil</li>
				</ul>
			</td>
			<td>scriptContext (added to path)
				<ul>
					<li>widget, pvs (accessible without context)</li>
					<li>PVUtil</li>
					<li>ScriptUtil</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td><b>imports</b></td>
			<td>libraries (numPy, sciPy, etc.)</td>
			<td>Java classes (inc. PVUtil, ScriptUtil)</td>
		</tr>
		<tr>
			<td><b>start display</b></td>
			<td>no initial start time</td>
			<td>a few seconds to start Jython interpreter</td>
		</tr>
		<tr>
			<td style="border-bottom: 0px"><b>start script</b></td>
			<td style="border-bottom: 0px">about a second per script</td>
			<td style="border-bottom: 0px">virtually no start time per script</td>
		</tr>
	</table>
</center>

<h2>JavaScript Scripts</h2>

<p>Similar to Jython, JavaScript can be used as a language
with execution inside the Java instance that also runs the Display builder.
</p>

<p>Any script file with a name that ends in ".js" executed as JavaScript.
In addition, the JavaScript code can be embedded in the *.bob file.
</p>


<h2>Threading</h2>

<p>Each *.bob display has one script execution thread and one instance of the
Jython, Python and JavaScript support.
This allows scripts to run in the background without negatively impacting the user interface thread.
It also allows scripts for different *.bob displays to execute in parallel.
</p>

<p>
To limit the use of resources, however, at most <u>one</u> script executes for a given *.bob
display at a time.
Furthermore, if a specific script is triggered by either an action or a PV change,
further invocations of that same script are ignored until the current execution of the script finishes.
</p>


<h2>API</h2>

<p>For details refer to the <a href="#get_started">examples</a>
and the

<!-- The java/* docs are created by the javadoc.xml ANT script
     in combination with the javadoc_overview.html file
  -->
<a href="java/overview-summary.html">Java documentation</a>
</p>


</body>
</html>
